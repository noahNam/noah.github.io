---
layout: post
title: Aggregate Root Transaction
description: >
    애그리거트 루트 트랜잭션 범위
sitemap: false
hide_last_modified: false
categories:
  - category
  - DDD
---


# 애그리거트 루트 트랜잭션 범위

* toc
{:toc .large-only}

## 트랜젝션 범위
- 트랜잭션 범위는 작을수록 좋다.
  - 한 트랜잭션이 한 개 테이블을 수정하는 것과 여러개의 테이블을 수정하는 것은 성능에서 차이가 발생한다.
  - 한 개의 테이블을 수정하면 트랜젝션 충돌을 막기 위한 Lock의 대상이 한 개 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 Locl 대상이 더 많아진다.
  - Lock 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜젝션 갯수가 줄어든다는 것을 의미하고 이것은 전체적인 성능을 떨어뜨린다.

- 마찬가지로, 한 트랜젝션에서 한 애그리거트만 수정되어야한다.
  - 한 트랜젝션에서 두 개 이상의 애그리거트를 수정하면 트랜젝션 충돌이 발생할 가능성이 높아진다.
  - 또한, 위에 적은대로 전체적인 성능(처리량)도 떨어지게 된다.

- 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
  - <strong>`한 애그리거트에서 다른 애그리거트를 수정하면 결과적으로 두 개의 애그리거트를 한 트랜젝션에서 수정하게 되므로, 애그리거트 내부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안된다.`</strong>
  - 예를 들어 배송지 정보(A 애그리거트)를 변경하면서 동시에 배송지 정보를 회원의 주소(B 애그리거트)로 설정하는 기능이 있는데, 이것을 하나의 트랜잭션으로 관리하게 되면 아래와 같은 문제가 발생한다.
    1. <strong>애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하게 된다.</strong>
    2. <strong>애그리거트는 서로 독립적이어야  하는데 의존성이 커지면서 결합도가 높아진다. 이는 유지보수 단계에서 수정 비용이 더 발생하는 원인이 된다.</strong>
    3. <strong>따라서, 부득이하게 한 트랜젝션으로 두 개이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 서비스 레이어에서 두 애그리거트를 수정하도록 구현한다.</strong>
      ```python
      class OrderService:
          ...
          def excute(self) -> None:
            ...

            order: OrderEntity = _order_repo.find_by_id(id)
            order.ship_to(new_Address)
            if not order:
              raise OrderNotFoundException()
            
            ...

            member: MemberEntity = _user_repo.find_by_id(id)
            member.change_address(new_address)
      ```

## 예외의 경우
- 한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만, 다음 경우에는 두 개 이상의 애그리거트를 변경하는 것을 고려할 수도 있다.
  1. 팀 표준: 팀이나 조직의 표준에 따라 유즈케이스와 관련된 서비스의 기능을 한 트랜잭션으로 실행하는 경우
  2. 기술 제약: 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 유지한다.